## 2019年4月22日 HZ 阴雨  风暴-0422

### Heap sort

起源于女朋友问的一个问题，在一个很大的数据中获得前K个大于X的Value.

这道题其实很容易解决，先排序即可。

面临着一个问题，数据量太大，需考虑无法一次性load进内存中。 在这种情况下，应该如何选择一种解决方案呢？


 我的答案是先将数据切割成不同的segment。对这些segment 进行排序后，合并排序。典型的Map reduce 过程。
 但是面临着一个问题，比如数据 1 3 4 5 6 和 2 3 4 6 7分别位于两个segment上的排好序的序列。

如果简单的合并  

-> 1 3 4 5 6 + 2 3 4 6 7

-> 1 + 2 3 4 6 7 +3 4 5 6

都会导致错误。（暂时忘记外部排序多路合并）

这种情况下，采用堆排序就非常合适。

构建一棵K个节点的完全二叉树（如大顶堆）。 这棵树可以存储大于X的前K个值。

大顶堆的核心原理是，从第一个非叶子节点开始不断的修正树以满足大顶堆的定义。

同时这种数据结构可以被影射到数组中。 比如2*i+1代表i的左子树，2*i+2代表i的右子树。



Reference: 
``` java

public static void adjustHeap(int []arr,int i,int length){
       int temp = arr[i];//先取出当前元素i
       for(int k=i*2+1;k<length;k=k*2+1){//从i结点的左子结点开始，也就是2i+1处开始
           if(k+1<length && arr[k]<arr[k+1]){//如果左子结点小于右子结点，k指向右子结点
               k++;
           }
           if(arr[k] >temp){//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
               arr[i] = arr[k];
               i = k;
           }else{
               break;
           }
       }
       arr[i] = temp;//将temp值放到最终的位置
   }
```
