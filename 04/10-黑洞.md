## 2019年4月10日 HZ 天气阴  风暴-0410

今天是一个非常特殊的日子，人类利用望远镜矩阵构建了一个直径为地球的超级望远镜观测到了黑洞并拍摄了照片。

黑洞连光都没办法逃逸？

最近一段时间，感觉自己的身体有点状况，需要看看皮肤医生。 这个计划在工作稳定后，就需要着手准备起来了。

安装了Linux之后，小米Pro的性能表现极其差。在测试中，我使用ubuntu 18.04 ，但会莫名的出现一些无法预料的奇怪bug。


重新思考分布式事务，XA（2PC） 还是TCC。都显得不够优雅。本地消息表仔细研究了下，确实是一种不错的思路，但是这个方法在2008年就被提出了，有点久远，难道最近几年都没有什么改变么？
我找到的这篇文章的地址在https://queue.acm.org/detail.cfm?id=1394128。

根据CAP定律，我们只能做取舍。  在分布式事务里面，尤其是微服务，一个经典的场景是，转账。

分布式事务T1分解操作如下：
- Action1 A用户减少钱
- Action2 B用户增加钱
假设这两个操作在不同的机器中，依赖网络传递触发执行，Action1执行在M1上，Action2执行在M2上。

如果Action1提交了事务成功，那么Action2一定要提交事务成功。

如果Action1提交事务失败，那么Action2也一定要提交事务失败。

这意味着，如果Action1提交了成功的事务，但Action2提交失败了，则Action1需要回滚。

在微服务里，Action1和Action2分布在不同的网络环境和机器上，依赖网络通信，这个过程并不是可靠的，在真实的世界里，会存在许许多多的问题，网络延迟、机器宕机、服务器内存不足等引起的各种问题会导致Action执行中断，一个分布式事务单元内包含了许多操作，其中一些成功了，但另一些失败了，这个情况会导致数据不一致。
分布式事务从各种方法极可能的使得事务的提交时可控的，每一个Action的事务操作可以利用数据库的事务。网络引起的事务失败，需要依赖某些机制进行补偿回滚等，


本地消息表 T1的核心逻辑可以解析为
事务1
1. 发送消息
2. 写本地消息
2. 执行Action1

事务2
1. 执行事务逻辑Action2
2. 消费消息

注意事务1执行Action1和写本地消息需要在一个数据库事务里面。 而发送消息是指将消息发送到mq 里面。事务2能感知到消息并且消费。
