## 2019年3月10日 HZ 天气阴  风暴-0310



技术上，


有非常非常多的新技术涌现出来，必须清楚的认识到，精力是有限的，需要对时间进行评估，看看那些时间需要做哪些事情。

技术上，需要对未来有一个清晰而明确的判断，控制时间和精力。也就是说，必须要让自己的知识体系完善起来，梳理知识网络，查漏补缺。 

技术是为人类服务的，但技术是超现实的。

需要明确的一点是，具体到某项技能，不要空谈抽象的东西，比如在记笔记的时候，聚焦在某个具体的细节上，否则一些很哲学的东西看上去好看，但其实没什么营养价值对目前的你。


#### B+树


B+数是Mysql底层最重要的数据结构。

第一个问题，什么是B+树，B+树在Wiki的定义如下
>  在B+树中的节点通常被表示为一组有序的元素和子指针。如果此B+树的阶数是m，则除了根之外的每个节点都包含最少 {\displaystyle \lceil m/2\rceil } 个元素最多 {\displaystyle m} 个元素，对于任意的结点有最多 m 个子指针。对于所有内部节点，子指针的数目总是与元素的数目相同。所有叶子都在相同的高度上，叶结点本身按关键字大小从小到大链接。

B+树的核心在于除了根之外的每个节点最多和最少的元素个数约束，这样做可以控制Tree的高度和宽度达到一种均衡。 如果太高，查询的速度就很低。如果太低，占据的空间有很大。

Mysql的查询语句如下：

``` sql

select * from table where a>1 
```

在这样一个查询中，我们需要遍历获取a>1的全部结果集。

这样的一个查询，如何构造一颗B+树呢？

假设我们有1000W条数据，为了查询的速度，就需要为某个字段建立索引。比如给a 字段索引。建立索引的过程其实就是构建B+树的过程（至少在Mysql中的实现如此）。

将数据存储在叶子节点，索引数据本身保存在磁盘上。
我们期望这棵树是
    1. 足够的低，这样可以减少磁盘IO，增大查询速度（磁盘IO 一次读取4K/1扇区）
    2. 内存友好，不要占据太多的内存。


数据真正被保存在叶子节点，每一次查询都需要从根节点走向叶子节点，为了保证查询效率恒定（不会出现有些查询不可预期的时间），所以，这棵树必须保证从根节点到叶子节点的路径是一致的。


插入数据 1 3 7 9 0 2 ,

插入 1，检测节点数为1，不需要调整
插入 3 ，检测节点数为2 ，小于4，不需要调整
插入7，检测到节点数为7，小于4，不需要调整
插入9，检测到节点数为9，需要调整，将3升级为。1 变成3的左子树，3、7、9 变成3的右子树。
插入0，检测到小于3，检查到小于1，插入到3的左子树，
插入2，检测到小于3，检测到大于2 ，插入到3的左子树，


``` java

 // CODE HERE 

```




