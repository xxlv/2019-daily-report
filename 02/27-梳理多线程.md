## 2019年2月27日 HZ 天气阴  风暴-027

系统的梳理一下并发问题，在Java中，java语言最大的优势之一就是并发的支持。

并发，简单通俗的讲，就是多个任务同时执行。但是我们知道一个事实，在单核CPU上，任务是抢占式执行的，任何一个时刻只有一个任务在执行。那么，并发是什么意思呢？在多核cpu的并发很容易理解，但是单核上为什么也有并发这个概念？

说起并发，其实并不真正的是并发，在单核cpu上只是看上去像是在同一个时刻执行多个任务而已。这其实是计算机对并发概念的一种硬件无关的抽象。在这个抽象中，我们是的并发本身并不依赖cpu，而依赖一种调度设计和概念。

在我的理解中，并发是一种cpu治理方式。我们需要制定一些规则来确保cpu正确的分配timeslice。这个过程需要抽象出一种模型，就是线程模型。

多线程模型在Java中非常经典，一个线程有自己的生命周期，

- New
- Runnable
- Blocked
- Timed Waiting 
- Waiting
- Terminated 

每一个状态都标记了当前线程的受限操作，比如只有当Runnable的线程才有资格获取CPU的青睐，而其它状态的线程都会想办法靠近转换成Runnable状态，直到线程进入Terminated。

线程的每一个状态都是必要存在的，线程在执行的时候可以被Interuped,也可以显式的调用wait,sleep。有些是因为业务需要，有些是因为意外打断，有些则是cpu。
要理解并清楚每一个线程状态，才能更好的理解多线程模型。比如理解Blocked状态，在这个状态下的线程，会争夺锁。持有对象的锁，比如通过Object的wait方法。

wait会释放锁，并让线程进入Blocked状态，这时候，当其他线程执行notify的时候，它就有机会获取到锁。在某些场景下，它是非常有用的。


多线程的模型的本质是要高效的利用cpu，是一种非常优雅的抽象。 多线程在编程的时候也非常有用，多个任务同时协作使得程序的执行效率更高，但是带来的弊端也要了解。一般的，对资源的竞争会导致不可预期的问题。
为了解决这些问题，通常引入锁。 当然还会有无锁编程的方案，比如CAS等。

多线程模型在Java中需要借助于Thread类来实现。 线程的核心工作在Runnable接口定义的run方法中。

但是，线程的创建需要消耗资源，所以频繁的创建在某些场景下是一种对资源的极大浪费，为了复用线程，一种方案是使用线程池。线程池的核心就是，当你需要一个线程来执行的时候，并不总是需要New。有可能只是Get。

New需要消耗资源，而Get几乎不需要，这时线程的复用。

在Java中，需要了解Executors类，它提供了一系列创建线程池的方法。这使得使用线程池也非常方面和透明。





